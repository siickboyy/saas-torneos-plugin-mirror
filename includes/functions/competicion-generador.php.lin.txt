     1	<?php
     2	/**
     3	 * Ruta: /saas-torneos-de-raqueta/includes/functions/competicion-generador.php
     4	 * Lógica de generación de estructura de competición desde snapshot.
     5	 */
     6	
     7	if (!defined('ABSPATH')) { exit; }
     8	
     9	/** Logger básico (usa el mismo que en otros archivos si ya existe) */
    10	if (!function_exists('str_saas_log')) {
    11	    function str_saas_log($message, $context = []) {
    12	        $base = dirname(dirname(__DIR__));
    13	        $log_path = trailingslashit($base) . 'debug-saas-torneos.log';
    14	        $line = '[' . date('Y-m-d H:i:s') . '] ' . (is_string($message) ? $message : wp_json_encode($message, JSON_UNESCAPED_UNICODE));
    15	        if (!empty($context)) { $line .= ' | ' . wp_json_encode($context, JSON_UNESCAPED_UNICODE); }
    16	        $line .= PHP_EOL;
    17	        @file_put_contents($log_path, $line, FILE_APPEND);
    18	    }
    19	}
    20	
    21	/** Carga snapshot desde transient/option por simulacion_id */
    22	function str_cargar_snapshot_por_id($simulacion_id) {
    23	    $key = 'str_simulacion_' . $simulacion_id;
    24	    $json = get_transient($key);
    25	    if (!$json) { $json = get_option($key, ''); }
    26	    if (!$json) { return null; }
    27	    $data = json_decode($json, true);
    28	    return (json_last_error() === JSON_ERROR_NONE) ? $data : null;
    29	}
    30	
    31	/** Crea parejas placeholder ligadas a una competición y devuelve array de IDs */
    32	function str_crear_parejas_placeholder($competicion_id, $total_parejas) {
    33	    $ids = [];
    34	    for ($i = 1; $i <= $total_parejas; $i++) {
    35	        $title = 'Pareja ' . $i;
    36	        $post_id = wp_insert_post([
    37	            'post_type'   => 'pareja',
    38	            'post_title'  => $title,
    39	            'post_status' => 'publish',
    40	            'post_author' => get_current_user_id()
    41	        ]);
    42	        if (is_wp_error($post_id)) {
    43	            str_saas_log('ERROR creando pareja placeholder', ['error' => $post_id->get_error_message(), 'i' => $i]);
    44	            continue;
    45	        }
    46	        update_post_meta($post_id, 'placeholder', 1);
    47	        update_post_meta($post_id, 'competicion_id', $competicion_id);
    48	        $ids[] = $post_id;
    49	    }
    50	    return $ids;
    51	}
    52	
    53	/** Crea un post de grupo y devuelve su ID */
    54	function str_crear_grupo($competicion_id, $letra, $orden, $tamano) {
    55	    $post_id = wp_insert_post([
    56	        'post_type'   => 'grupo',
    57	        'post_title'  => 'Grupo ' . $letra,
    58	        'post_status' => 'publish',
    59	        'post_author' => get_current_user_id()
    60	    ]);
    61	    if (is_wp_error($post_id)) {
    62	        str_saas_log('ERROR creando grupo', ['letra' => $letra, 'error' => $post_id->get_error_message()]);
    63	        return 0;
    64	    }
    65	    update_post_meta($post_id, 'competicion_id', $competicion_id);
    66	    update_post_meta($post_id, 'letra', $letra);
    67	    update_post_meta($post_id, 'orden', $orden);
    68	    update_post_meta($post_id, 'tam', $tamano);
    69	    return $post_id;
    70	}
    71	
    72	/** Genera todos los partidos round-robin dentro de un grupo (con parejas asignadas) */
    73	function str_generar_partidos_grupo($competicion_id, $grupo_id, $parejas_ids) {
    74	    $n = count($parejas_ids);
    75	    for ($i = 0; $i < $n; $i++) {
    76	        for ($j = $i + 1; $j < $n; $j++) {
    77	            $p1 = $parejas_ids[$i];
    78	            $p2 = $parejas_ids[$j];
    79	            $pid = wp_insert_post([
    80	                'post_type'   => 'partido',
    81	                'post_title'  => 'Grupo ' . get_post_meta($grupo_id, 'letra', true) . ': ' . get_the_title($p1) . ' vs ' . get_the_title($p2),
    82	                'post_status' => 'publish',
    83	                'post_author' => get_current_user_id()
    84	            ]);
    85	            if (is_wp_error($pid)) {
    86	                str_saas_log('ERROR creando partido grupo', ['grupo_id' => $grupo_id, 'error' => $pid->get_error_message()]);
    87	                continue;
    88	            }
    89	            // Meta: enlazamos correctamente
    90	            update_post_meta($pid, 'competicion_padel', $competicion_id); // ACF relación a competición
    91	            update_post_meta($pid, 'grupo_id', $grupo_id);
    92	            update_post_meta($pid, 'ronda', 'Grupos'); // coincide con tu ACF "Ronda"
    93	            update_post_meta($pid, 'estado', 'Pendiente');
    94	            // Relaciones a parejas (ACF espera IDs)
    95	            update_post_meta($pid, 'pareja_1', $p1);
    96	            update_post_meta($pid, 'pareja_2', $p2);
    97	        }
    98	    }
    99	}
   100	
   101	/** Crea un partido del cuadro con slots (pareja_a/b vacías hasta que se conozcan). Devuelve ID */
   102	function str_crear_partido_bracket($competicion_id, $ronda_label, $slot_a, $slot_b, $orden = 1, $grupo_letra = '') {
   103	    $title = ($grupo_letra ? "Grupo $grupo_letra – " : '') . "$ronda_label: $slot_a vs $slot_b";
   104	    $pid = wp_insert_post([
   105	        'post_type'   => 'partido',
   106	        'post_title'  => $title,
   107	        'post_status' => 'publish',
   108	        'post_author' => get_current_user_id()
   109	    ]);
   110	    if (is_wp_error($pid)) {
   111	        str_saas_log('ERROR creando partido bracket', ['slot_a' => $slot_a, 'slot_b' => $slot_b, 'error' => $pid->get_error_message()]);
   112	        return 0;
   113	    }
   114	    update_post_meta($pid, 'competicion_padel', $competicion_id);
   115	    update_post_meta($pid, 'ronda', $ronda_label); // 'Cuartos' | 'Semis' | 'Final'
   116	    update_post_meta($pid, 'estado', 'Pendiente');
   117	    update_post_meta($pid, 'slot_a', $slot_a);
   118	    update_post_meta($pid, 'slot_b', $slot_b);
   119	    update_post_meta($pid, 'orden', intval($orden));
   120	    if ($grupo_letra) { update_post_meta($pid, 'grupo_bracket', $grupo_letra); }
   121	    // Sin pareja_1/pareja_2 todavía (se rellenarán cuando haya clasificación)
   122	    return $pid;
   123	}
   124	
   125	/** Genera el bracket (premios por grupo o mezclar) en función de la fase final */
   126	function str_generar_bracket($competicion_id, $modo_final, $fase_final, $grupos_info) {
   127	    // $grupos_info: array [['letra'=>'A','tam'=>4,...], ...]
   128	    $fase_final = strtolower($fase_final); // final|semifinal|cuartos|octavos
   129	    $modo_final = strtolower($modo_final); // premios_grupo|mezclar
   130	
   131	    if ($modo_final === 'premios_grupo') {
   132	        // Minibrackets independientes por grupo
   133	        foreach ($grupos_info as $g) {
   134	            $L = $g['letra'];
   135	            switch ($fase_final) {
   136	                case 'final':
   137	                    str_crear_partido_bracket($competicion_id, 'Final', "1º $L", "2º $L", 1, $L);
   138	                    break;
   139	                case 'semifinal':
   140	                    str_crear_partido_bracket($competicion_id, 'Semis', "1º $L", "4º $L", 1, $L);
   141	                    str_crear_partido_bracket($competicion_id, 'Semis', "2º $L", "3º $L", 2, $L);
   142	                    str_crear_partido_bracket($competicion_id, 'Final', "Ganador S1 ($L)", "Ganador S2 ($L)", 3, $L);
   143	                    break;
   144	                case 'cuartos':
   145	                    // Cuartos: 1º vs 4º y 2º vs 3º (dos cruces)
   146	                    str_crear_partido_bracket($competicion_id, 'Cuartos', "1º $L", "4º $L", 1, $L);
   147	                    str_crear_partido_bracket($competicion_id, 'Cuartos', "2º $L", "3º $L", 2, $L);
   148	                    // Semis con Ganadores de Cuartos
   149	                    str_crear_partido_bracket($competicion_id, 'Semis', "Ganador Q1 ($L)", "Ganador Q2 ($L)", 3, $L);
   150	                    // Final
   151	                    str_crear_partido_bracket($competicion_id, 'Final', "Ganador S1 ($L)", "Ganador S2 ($L)", 4, $L);
   152	                    break;
   153	                case 'octavos':
   154	                    // Demasiado grande por grupo en la práctica; dejamos estructura indicativa:
   155	                    for ($i=1; $i<=4; $i++) {
   156	                        str_crear_partido_bracket($competicion_id, 'Octavos', "Seed ".(2*$i-1)." $L", "Seed ".(2*$i)." $L", $i, $L);
   157	                    }
   158	                    // Cuartos, Semis, Final como progresión
   159	                    for ($i=1; $i<=2; $i++) {
   160	                        str_crear_partido_bracket($competicion_id, 'Cuartos', "Ganador O".(2*$i-1)." ($L)", "Ganador O".(2*$i)." ($L)", $i, $L);
   161	                    }
   162	                    str_crear_partido_bracket($competicion_id, 'Semis', "Ganador C1 ($L)", "Ganador C2 ($L)", 1, $L);
   163	                    str_crear_partido_bracket($competicion_id, 'Final', "Ganador S1 ($L)", "Ganador S2 ($L)", 1, $L);
   164	                    break;
   165	            }
   166	        }
   167	        return;
   168	    }
   169	
   170	    // MODO: MEZCLAR GRUPOS (bracket único)
   171	    $letras = array_map(function($g){ return $g['letra']; }, $grupos_info);
   172	    $G = count($letras);
   173	
   174	    switch ($fase_final) {
   175	        case 'final':
   176	            // Suponiendo 2 plazas totales: 1º de los dos mejores grupos o del ranking general
   177	            // Estructura de slots: genérica
   178	            str_crear_partido_bracket($competicion_id, 'Final', "1º A", (isset($letras[1]) ? "1º " . $letras[1] : "1º B"), 1);
   179	            break;
   180	
   181	        case 'semifinal':
   182	            // 4 plazas: cruce 1ºA vs 2ºB y 1ºB vs 2ºA (si G>=2). Con más grupos, el mapeo puede ser A-B y C-D etc.
   183	            if ($G >= 2) {
   184	                str_crear_partido_bracket($competicion_id, 'Semis', "1º {$letras[0]}", "2º {$letras[1]}", 1);
   185	                str_crear_partido_bracket($competicion_id, 'Semis', "1º {$letras[1]}", "2º {$letras[0]}", 2);
   186	            } else {
   187	                // Si sólo hay 1 grupo: 1º vs 2º
   188	                str_crear_partido_bracket($competicion_id, 'Semis', "1º {$letras[0]}", "2º {$letras[0]}", 1);
   189	                str_crear_partido_bracket($competicion_id, 'Semis', "3º {$letras[0]}", "4º {$letras[0]}", 2);
   190	            }
   191	            str_crear_partido_bracket($competicion_id, 'Final', "Ganador S1", "Ganador S2", 3);
   192	            break;
   193	
   194	        case 'cuartos':
   195	            // 8 plazas. Con G pares: A vs B, C vs D, etc. Slots típicos:
   196	            // QF1: 1ºA vs 2ºB, QF2: 1ºB vs 2ºA, QF3: 1ºC vs 2ºD, QF4: 1ºD vs 2ºC, ...
   197	            $orden = 1;
   198	            for ($i = 0; $i < $G; $i += 2) {
   199	                $L1 = $letras[$i];
   200	                $L2 = isset($letras[$i+1]) ? $letras[$i+1] : $L1;
   201	                str_crear_partido_bracket($competicion_id, 'Cuartos', "1º $L1", "2º $L2", $orden++);
   202	                str_crear_partido_bracket($competicion_id, 'Cuartos', "1º $L2", "2º $L1", $orden++);
   203	            }
   204	            // Semis y Final (con ganadores ordenados)
   205	            str_crear_partido_bracket($competicion_id, 'Semis', "Ganador Q1", "Ganador Q2", 1);
   206	            str_crear_partido_bracket($competicion_id, 'Semis', "Ganador Q3", "Ganador Q4", 2);
   207	            str_crear_partido_bracket($competicion_id, 'Final', "Ganador S1", "Ganador S2", 3);
   208	            break;
   209	
   210	        case 'octavos':
   211	            // 16 plazas, mapeo similar en bloques de 4 grupos. Por brevedad, estructura indicativa:
   212	            for ($i=1; $i<=8; $i++) {
   213	                str_crear_partido_bracket($competicion_id, 'Octavos', "Seed ".(2*$i-1), "Seed ".(2*$i), $i);
   214	            }
   215	            for ($i=1; $i<=4; $i++) {
   216	                str_crear_partido_bracket($competicion_id, 'Cuartos', "Ganador O".(2*$i-1), "Ganador O".(2*$i), $i);
   217	            }
   218	            str_crear_partido_bracket($competicion_id, 'Semis', "Ganador C1", "Ganador C2", 1);
   219	            str_crear_partido_bracket($competicion_id, 'Semis', "Ganador C3", "Ganador C4", 2);
   220	            str_crear_partido_bracket($competicion_id, 'Final', "Ganador S1", "Ganador S2", 3);
   221	            break;
   222	    }
   223	}
   224	
   225	/**
   226	 * FUNCIÓN PRINCIPAL: Generar estructura completa desde simulación
   227	 * - Crea parejas placeholder
   228	 * - Crea grupos y asigna parejas por orden
   229	 * - Crea partidos round-robin
   230	 * - Crea bracket por slots (sin asignar parejas aún)
   231	 */
   232	function str_generar_competicion_desde_snapshot($competicion_id, $simulacion_id) {
   233	    $snapshot = str_cargar_snapshot_por_id($simulacion_id);
   234	    if (!is_array($snapshot)) {
   235	        str_saas_log('SNAPSHOT no encontrado', ['simulacion_id' => $simulacion_id]);
   236	        return new WP_Error('snapshot_not_found', 'No se pudo cargar el snapshot de simulación.');
   237	    }
   238	
   239	    $P           = intval($snapshot['n_parejas_calc']);
   240	    $n_grupos    = intval($snapshot['n_grupos']);
   241	    $fase_final  = $snapshot['fase_final'];
   242	    $modo_final  = $snapshot['cuadro_opcion']; // 'premios_grupo' | 'mezclar'
   243	    $grupos_snap = $snapshot['grupos'];        // [['nombre'=>'A','tam'=>X,'participantes'=>[...] ]...]
   244	
   245	    if ($P < 2 || $n_grupos < 1 || empty($grupos_snap)) {
   246	        return new WP_Error('snapshot_invalido', 'Snapshot de simulación incompleto.');
   247	    }
   248	
   249	    // 1) Parejas placeholder
   250	    $parejas_ids = str_crear_parejas_placeholder($competicion_id, $P);
   251	    if (count($parejas_ids) < $P) {
   252	        str_saas_log('WARNING parejas placeholder incompletas', ['esperadas' => $P, 'creadas' => count($parejas_ids)]);
   253	    }
   254	
   255	    // 2) Crear grupos y asignar parejas por orden
   256	    $letras = range('A', 'Z');
   257	    $offset = 0;
   258	    $grupos_creados = []; // para bracket
   259	    foreach ($grupos_snap as $idx => $g) {
   260	        $letra = isset($g['nombre']) ? $g['nombre'] : ( $letras[$idx] ?? 'G'.($idx+1) );
   261	        $tam   = isset($g['tam']) ? intval($g['tam']) : 0;
   262	
   263	        $grupo_id = str_crear_grupo($competicion_id, $letra, $idx+1, $tam);
   264	        if ($grupo_id <= 0) { continue; }
   265	
   266	        // Asignar parejas al grupo (por índice)
   267	        $asignadas = array_slice($parejas_ids, $offset, $tam);
   268	        $offset += $tam;
   269	
   270	        // Guardar lista en meta (IDs de parejas en el grupo)
   271	        update_post_meta($grupo_id, 'participantes', $asignadas);
   272	
   273	        // 3) Fixtures round-robin de este grupo
   274	        if (count($asignadas) >= 2) {
   275	            str_generar_partidos_grupo($competicion_id, $grupo_id, $asignadas);
   276	        }
   277	
   278	        $grupos_creados[] = ['letra' => $letra, 'id' => $grupo_id, 'tam' => $tam];
   279	    }
   280	
   281	    // 4) Bracket (slots)
   282	    str_generar_bracket($competicion_id, $modo_final, $fase_final, $grupos_creados);
   283	
   284	    // 5) Guardar algunos metas globales para referencia
   285	    update_post_meta($competicion_id, 'str_estructura_generada', 1);
   286	    update_post_meta($competicion_id, 'str_mapa_slots_bracket', wp_json_encode([
   287	        'modo'  => $modo_final,
   288	        'fase'  => $fase_final,
   289	        'grupos'=> array_map(function($g){ return $g['letra']; }, $grupos_creados)
   290	    ], JSON_UNESCAPED_UNICODE));
   291	
   292	    str_saas_log('ESTRUCTURA generada', [
   293	        'competicion_id' => $competicion_id,
   294	        'simulacion_id'  => $simulacion_id,
   295	        'parejas'        => count($parejas_ids),
   296	        'grupos'         => count($grupos_creados),
   297	        'fase'           => $fase_final,
   298	        'modo'           => $modo_final
   299	    ]);
   300	
   301	    return true;
   302	}
